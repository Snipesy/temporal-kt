// Generated by jextract

package io.temporal.sdkbridge;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct TemporalCoreDevServerOptions {
 *     const struct TemporalCoreTestServerOptions *test_server;
 *     struct TemporalCoreByteArrayRef namespace_;
 *     struct TemporalCoreByteArrayRef ip;
 *     struct TemporalCoreByteArrayRef database_filename;
 *     bool ui;
 *     uint16_t ui_port;
 *     struct TemporalCoreByteArrayRef log_format;
 *     struct TemporalCoreByteArrayRef log_level;
 * }
 * }
 */
public class TemporalCoreDevServerOptions {

    TemporalCoreDevServerOptions() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        temporal_sdk_core_c_bridge_h.C_POINTER.withName("test_server"),
        TemporalCoreByteArrayRef.layout().withName("namespace_"),
        TemporalCoreByteArrayRef.layout().withName("ip"),
        TemporalCoreByteArrayRef.layout().withName("database_filename"),
        temporal_sdk_core_c_bridge_h.C_BOOL.withName("ui"),
        MemoryLayout.paddingLayout(1),
        temporal_sdk_core_c_bridge_h.C_SHORT.withName("ui_port"),
        MemoryLayout.paddingLayout(4),
        TemporalCoreByteArrayRef.layout().withName("log_format"),
        TemporalCoreByteArrayRef.layout().withName("log_level")
    ).withName("TemporalCoreDevServerOptions");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout test_server$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("test_server"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct TemporalCoreTestServerOptions *test_server
     * }
     */
    public static final AddressLayout test_server$layout() {
        return test_server$LAYOUT;
    }

    private static final long test_server$OFFSET = $LAYOUT.byteOffset(groupElement("test_server"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct TemporalCoreTestServerOptions *test_server
     * }
     */
    public static final long test_server$offset() {
        return test_server$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct TemporalCoreTestServerOptions *test_server
     * }
     */
    public static MemorySegment test_server(MemorySegment struct) {
        return struct.get(test_server$LAYOUT, test_server$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct TemporalCoreTestServerOptions *test_server
     * }
     */
    public static void test_server(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(test_server$LAYOUT, test_server$OFFSET, fieldValue);
    }

    private static final GroupLayout namespace_$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("namespace_"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static final GroupLayout namespace_$layout() {
        return namespace_$LAYOUT;
    }

    private static final long namespace_$OFFSET = $LAYOUT.byteOffset(groupElement("namespace_"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static final long namespace_$offset() {
        return namespace_$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static MemorySegment namespace_(MemorySegment struct) {
        return struct.asSlice(namespace_$OFFSET, namespace_$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static void namespace_(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, namespace_$OFFSET, namespace_$LAYOUT.byteSize());
    }

    private static final GroupLayout ip$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("ip"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef ip
     * }
     */
    public static final GroupLayout ip$layout() {
        return ip$LAYOUT;
    }

    private static final long ip$OFFSET = $LAYOUT.byteOffset(groupElement("ip"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef ip
     * }
     */
    public static final long ip$offset() {
        return ip$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef ip
     * }
     */
    public static MemorySegment ip(MemorySegment struct) {
        return struct.asSlice(ip$OFFSET, ip$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef ip
     * }
     */
    public static void ip(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, ip$OFFSET, ip$LAYOUT.byteSize());
    }

    private static final GroupLayout database_filename$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("database_filename"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef database_filename
     * }
     */
    public static final GroupLayout database_filename$layout() {
        return database_filename$LAYOUT;
    }

    private static final long database_filename$OFFSET = $LAYOUT.byteOffset(groupElement("database_filename"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef database_filename
     * }
     */
    public static final long database_filename$offset() {
        return database_filename$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef database_filename
     * }
     */
    public static MemorySegment database_filename(MemorySegment struct) {
        return struct.asSlice(database_filename$OFFSET, database_filename$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef database_filename
     * }
     */
    public static void database_filename(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, database_filename$OFFSET, database_filename$LAYOUT.byteSize());
    }

    private static final OfBoolean ui$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("ui"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool ui
     * }
     */
    public static final OfBoolean ui$layout() {
        return ui$LAYOUT;
    }

    private static final long ui$OFFSET = $LAYOUT.byteOffset(groupElement("ui"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool ui
     * }
     */
    public static final long ui$offset() {
        return ui$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool ui
     * }
     */
    public static boolean ui(MemorySegment struct) {
        return struct.get(ui$LAYOUT, ui$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool ui
     * }
     */
    public static void ui(MemorySegment struct, boolean fieldValue) {
        struct.set(ui$LAYOUT, ui$OFFSET, fieldValue);
    }

    private static final OfShort ui_port$LAYOUT = (OfShort)$LAYOUT.select(groupElement("ui_port"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint16_t ui_port
     * }
     */
    public static final OfShort ui_port$layout() {
        return ui_port$LAYOUT;
    }

    private static final long ui_port$OFFSET = $LAYOUT.byteOffset(groupElement("ui_port"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint16_t ui_port
     * }
     */
    public static final long ui_port$offset() {
        return ui_port$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint16_t ui_port
     * }
     */
    public static short ui_port(MemorySegment struct) {
        return struct.get(ui_port$LAYOUT, ui_port$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint16_t ui_port
     * }
     */
    public static void ui_port(MemorySegment struct, short fieldValue) {
        struct.set(ui_port$LAYOUT, ui_port$OFFSET, fieldValue);
    }

    private static final GroupLayout log_format$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("log_format"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_format
     * }
     */
    public static final GroupLayout log_format$layout() {
        return log_format$LAYOUT;
    }

    private static final long log_format$OFFSET = $LAYOUT.byteOffset(groupElement("log_format"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_format
     * }
     */
    public static final long log_format$offset() {
        return log_format$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_format
     * }
     */
    public static MemorySegment log_format(MemorySegment struct) {
        return struct.asSlice(log_format$OFFSET, log_format$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_format
     * }
     */
    public static void log_format(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, log_format$OFFSET, log_format$LAYOUT.byteSize());
    }

    private static final GroupLayout log_level$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("log_level"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_level
     * }
     */
    public static final GroupLayout log_level$layout() {
        return log_level$LAYOUT;
    }

    private static final long log_level$OFFSET = $LAYOUT.byteOffset(groupElement("log_level"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_level
     * }
     */
    public static final long log_level$offset() {
        return log_level$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_level
     * }
     */
    public static MemorySegment log_level(MemorySegment struct) {
        return struct.asSlice(log_level$OFFSET, log_level$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef log_level
     * }
     */
    public static void log_level(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, log_level$OFFSET, log_level$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

