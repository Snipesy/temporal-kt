// Generated by jextract

package io.temporal.sdkbridge;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct TemporalCoreWorkerOptions {
 *     struct TemporalCoreByteArrayRef namespace_;
 *     struct TemporalCoreByteArrayRef task_queue;
 *     struct TemporalCoreWorkerVersioningStrategy versioning_strategy;
 *     struct TemporalCoreByteArrayRef identity_override;
 *     uint32_t max_cached_workflows;
 *     struct TemporalCoreTunerHolder tuner;
 *     struct TemporalCoreWorkerTaskTypes task_types;
 *     uint64_t sticky_queue_schedule_to_start_timeout_millis;
 *     uint64_t max_heartbeat_throttle_interval_millis;
 *     uint64_t default_heartbeat_throttle_interval_millis;
 *     double max_activities_per_second;
 *     double max_task_queue_activities_per_second;
 *     uint64_t graceful_shutdown_period_millis;
 *     struct TemporalCorePollerBehavior workflow_task_poller_behavior;
 *     float nonsticky_to_sticky_poll_ratio;
 *     struct TemporalCorePollerBehavior activity_task_poller_behavior;
 *     struct TemporalCorePollerBehavior nexus_task_poller_behavior;
 *     bool nondeterminism_as_workflow_fail;
 *     struct TemporalCoreByteArrayRefArray nondeterminism_as_workflow_fail_for_types;
 *     struct TemporalCoreByteArrayRefArray plugins;
 * }
 * }
 */
public class TemporalCoreWorkerOptions {

    TemporalCoreWorkerOptions() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        TemporalCoreByteArrayRef.layout().withName("namespace_"),
        TemporalCoreByteArrayRef.layout().withName("task_queue"),
        TemporalCoreWorkerVersioningStrategy.layout().withName("versioning_strategy"),
        TemporalCoreByteArrayRef.layout().withName("identity_override"),
        temporal_sdk_core_c_bridge_h.C_INT.withName("max_cached_workflows"),
        MemoryLayout.paddingLayout(4),
        TemporalCoreTunerHolder.layout().withName("tuner"),
        TemporalCoreWorkerTaskTypes.layout().withName("task_types"),
        MemoryLayout.paddingLayout(4),
        temporal_sdk_core_c_bridge_h.C_LONG_LONG.withName("sticky_queue_schedule_to_start_timeout_millis"),
        temporal_sdk_core_c_bridge_h.C_LONG_LONG.withName("max_heartbeat_throttle_interval_millis"),
        temporal_sdk_core_c_bridge_h.C_LONG_LONG.withName("default_heartbeat_throttle_interval_millis"),
        temporal_sdk_core_c_bridge_h.C_DOUBLE.withName("max_activities_per_second"),
        temporal_sdk_core_c_bridge_h.C_DOUBLE.withName("max_task_queue_activities_per_second"),
        temporal_sdk_core_c_bridge_h.C_LONG_LONG.withName("graceful_shutdown_period_millis"),
        TemporalCorePollerBehavior.layout().withName("workflow_task_poller_behavior"),
        temporal_sdk_core_c_bridge_h.C_FLOAT.withName("nonsticky_to_sticky_poll_ratio"),
        MemoryLayout.paddingLayout(4),
        TemporalCorePollerBehavior.layout().withName("activity_task_poller_behavior"),
        TemporalCorePollerBehavior.layout().withName("nexus_task_poller_behavior"),
        temporal_sdk_core_c_bridge_h.C_BOOL.withName("nondeterminism_as_workflow_fail"),
        MemoryLayout.paddingLayout(7),
        TemporalCoreByteArrayRefArray.layout().withName("nondeterminism_as_workflow_fail_for_types"),
        TemporalCoreByteArrayRefArray.layout().withName("plugins")
    ).withName("TemporalCoreWorkerOptions");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout namespace_$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("namespace_"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static final GroupLayout namespace_$layout() {
        return namespace_$LAYOUT;
    }

    private static final long namespace_$OFFSET = $LAYOUT.byteOffset(groupElement("namespace_"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static final long namespace_$offset() {
        return namespace_$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static MemorySegment namespace_(MemorySegment struct) {
        return struct.asSlice(namespace_$OFFSET, namespace_$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef namespace_
     * }
     */
    public static void namespace_(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, namespace_$OFFSET, namespace_$LAYOUT.byteSize());
    }

    private static final GroupLayout task_queue$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("task_queue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef task_queue
     * }
     */
    public static final GroupLayout task_queue$layout() {
        return task_queue$LAYOUT;
    }

    private static final long task_queue$OFFSET = $LAYOUT.byteOffset(groupElement("task_queue"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef task_queue
     * }
     */
    public static final long task_queue$offset() {
        return task_queue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef task_queue
     * }
     */
    public static MemorySegment task_queue(MemorySegment struct) {
        return struct.asSlice(task_queue$OFFSET, task_queue$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef task_queue
     * }
     */
    public static void task_queue(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, task_queue$OFFSET, task_queue$LAYOUT.byteSize());
    }

    private static final GroupLayout versioning_strategy$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("versioning_strategy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerVersioningStrategy versioning_strategy
     * }
     */
    public static final GroupLayout versioning_strategy$layout() {
        return versioning_strategy$LAYOUT;
    }

    private static final long versioning_strategy$OFFSET = $LAYOUT.byteOffset(groupElement("versioning_strategy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerVersioningStrategy versioning_strategy
     * }
     */
    public static final long versioning_strategy$offset() {
        return versioning_strategy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerVersioningStrategy versioning_strategy
     * }
     */
    public static MemorySegment versioning_strategy(MemorySegment struct) {
        return struct.asSlice(versioning_strategy$OFFSET, versioning_strategy$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerVersioningStrategy versioning_strategy
     * }
     */
    public static void versioning_strategy(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, versioning_strategy$OFFSET, versioning_strategy$LAYOUT.byteSize());
    }

    private static final GroupLayout identity_override$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("identity_override"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef identity_override
     * }
     */
    public static final GroupLayout identity_override$layout() {
        return identity_override$LAYOUT;
    }

    private static final long identity_override$OFFSET = $LAYOUT.byteOffset(groupElement("identity_override"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef identity_override
     * }
     */
    public static final long identity_override$offset() {
        return identity_override$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef identity_override
     * }
     */
    public static MemorySegment identity_override(MemorySegment struct) {
        return struct.asSlice(identity_override$OFFSET, identity_override$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef identity_override
     * }
     */
    public static void identity_override(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, identity_override$OFFSET, identity_override$LAYOUT.byteSize());
    }

    private static final OfInt max_cached_workflows$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_cached_workflows"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_cached_workflows
     * }
     */
    public static final OfInt max_cached_workflows$layout() {
        return max_cached_workflows$LAYOUT;
    }

    private static final long max_cached_workflows$OFFSET = $LAYOUT.byteOffset(groupElement("max_cached_workflows"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_cached_workflows
     * }
     */
    public static final long max_cached_workflows$offset() {
        return max_cached_workflows$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_cached_workflows
     * }
     */
    public static int max_cached_workflows(MemorySegment struct) {
        return struct.get(max_cached_workflows$LAYOUT, max_cached_workflows$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_cached_workflows
     * }
     */
    public static void max_cached_workflows(MemorySegment struct, int fieldValue) {
        struct.set(max_cached_workflows$LAYOUT, max_cached_workflows$OFFSET, fieldValue);
    }

    private static final GroupLayout tuner$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("tuner"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreTunerHolder tuner
     * }
     */
    public static final GroupLayout tuner$layout() {
        return tuner$LAYOUT;
    }

    private static final long tuner$OFFSET = $LAYOUT.byteOffset(groupElement("tuner"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreTunerHolder tuner
     * }
     */
    public static final long tuner$offset() {
        return tuner$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreTunerHolder tuner
     * }
     */
    public static MemorySegment tuner(MemorySegment struct) {
        return struct.asSlice(tuner$OFFSET, tuner$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreTunerHolder tuner
     * }
     */
    public static void tuner(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, tuner$OFFSET, tuner$LAYOUT.byteSize());
    }

    private static final GroupLayout task_types$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("task_types"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerTaskTypes task_types
     * }
     */
    public static final GroupLayout task_types$layout() {
        return task_types$LAYOUT;
    }

    private static final long task_types$OFFSET = $LAYOUT.byteOffset(groupElement("task_types"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerTaskTypes task_types
     * }
     */
    public static final long task_types$offset() {
        return task_types$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerTaskTypes task_types
     * }
     */
    public static MemorySegment task_types(MemorySegment struct) {
        return struct.asSlice(task_types$OFFSET, task_types$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreWorkerTaskTypes task_types
     * }
     */
    public static void task_types(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, task_types$OFFSET, task_types$LAYOUT.byteSize());
    }

    private static final OfLong sticky_queue_schedule_to_start_timeout_millis$LAYOUT = (OfLong)$LAYOUT.select(groupElement("sticky_queue_schedule_to_start_timeout_millis"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t sticky_queue_schedule_to_start_timeout_millis
     * }
     */
    public static final OfLong sticky_queue_schedule_to_start_timeout_millis$layout() {
        return sticky_queue_schedule_to_start_timeout_millis$LAYOUT;
    }

    private static final long sticky_queue_schedule_to_start_timeout_millis$OFFSET = $LAYOUT.byteOffset(groupElement("sticky_queue_schedule_to_start_timeout_millis"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t sticky_queue_schedule_to_start_timeout_millis
     * }
     */
    public static final long sticky_queue_schedule_to_start_timeout_millis$offset() {
        return sticky_queue_schedule_to_start_timeout_millis$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t sticky_queue_schedule_to_start_timeout_millis
     * }
     */
    public static long sticky_queue_schedule_to_start_timeout_millis(MemorySegment struct) {
        return struct.get(sticky_queue_schedule_to_start_timeout_millis$LAYOUT, sticky_queue_schedule_to_start_timeout_millis$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t sticky_queue_schedule_to_start_timeout_millis
     * }
     */
    public static void sticky_queue_schedule_to_start_timeout_millis(MemorySegment struct, long fieldValue) {
        struct.set(sticky_queue_schedule_to_start_timeout_millis$LAYOUT, sticky_queue_schedule_to_start_timeout_millis$OFFSET, fieldValue);
    }

    private static final OfLong max_heartbeat_throttle_interval_millis$LAYOUT = (OfLong)$LAYOUT.select(groupElement("max_heartbeat_throttle_interval_millis"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t max_heartbeat_throttle_interval_millis
     * }
     */
    public static final OfLong max_heartbeat_throttle_interval_millis$layout() {
        return max_heartbeat_throttle_interval_millis$LAYOUT;
    }

    private static final long max_heartbeat_throttle_interval_millis$OFFSET = $LAYOUT.byteOffset(groupElement("max_heartbeat_throttle_interval_millis"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t max_heartbeat_throttle_interval_millis
     * }
     */
    public static final long max_heartbeat_throttle_interval_millis$offset() {
        return max_heartbeat_throttle_interval_millis$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t max_heartbeat_throttle_interval_millis
     * }
     */
    public static long max_heartbeat_throttle_interval_millis(MemorySegment struct) {
        return struct.get(max_heartbeat_throttle_interval_millis$LAYOUT, max_heartbeat_throttle_interval_millis$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t max_heartbeat_throttle_interval_millis
     * }
     */
    public static void max_heartbeat_throttle_interval_millis(MemorySegment struct, long fieldValue) {
        struct.set(max_heartbeat_throttle_interval_millis$LAYOUT, max_heartbeat_throttle_interval_millis$OFFSET, fieldValue);
    }

    private static final OfLong default_heartbeat_throttle_interval_millis$LAYOUT = (OfLong)$LAYOUT.select(groupElement("default_heartbeat_throttle_interval_millis"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t default_heartbeat_throttle_interval_millis
     * }
     */
    public static final OfLong default_heartbeat_throttle_interval_millis$layout() {
        return default_heartbeat_throttle_interval_millis$LAYOUT;
    }

    private static final long default_heartbeat_throttle_interval_millis$OFFSET = $LAYOUT.byteOffset(groupElement("default_heartbeat_throttle_interval_millis"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t default_heartbeat_throttle_interval_millis
     * }
     */
    public static final long default_heartbeat_throttle_interval_millis$offset() {
        return default_heartbeat_throttle_interval_millis$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t default_heartbeat_throttle_interval_millis
     * }
     */
    public static long default_heartbeat_throttle_interval_millis(MemorySegment struct) {
        return struct.get(default_heartbeat_throttle_interval_millis$LAYOUT, default_heartbeat_throttle_interval_millis$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t default_heartbeat_throttle_interval_millis
     * }
     */
    public static void default_heartbeat_throttle_interval_millis(MemorySegment struct, long fieldValue) {
        struct.set(default_heartbeat_throttle_interval_millis$LAYOUT, default_heartbeat_throttle_interval_millis$OFFSET, fieldValue);
    }

    private static final OfDouble max_activities_per_second$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("max_activities_per_second"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double max_activities_per_second
     * }
     */
    public static final OfDouble max_activities_per_second$layout() {
        return max_activities_per_second$LAYOUT;
    }

    private static final long max_activities_per_second$OFFSET = $LAYOUT.byteOffset(groupElement("max_activities_per_second"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double max_activities_per_second
     * }
     */
    public static final long max_activities_per_second$offset() {
        return max_activities_per_second$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double max_activities_per_second
     * }
     */
    public static double max_activities_per_second(MemorySegment struct) {
        return struct.get(max_activities_per_second$LAYOUT, max_activities_per_second$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double max_activities_per_second
     * }
     */
    public static void max_activities_per_second(MemorySegment struct, double fieldValue) {
        struct.set(max_activities_per_second$LAYOUT, max_activities_per_second$OFFSET, fieldValue);
    }

    private static final OfDouble max_task_queue_activities_per_second$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("max_task_queue_activities_per_second"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double max_task_queue_activities_per_second
     * }
     */
    public static final OfDouble max_task_queue_activities_per_second$layout() {
        return max_task_queue_activities_per_second$LAYOUT;
    }

    private static final long max_task_queue_activities_per_second$OFFSET = $LAYOUT.byteOffset(groupElement("max_task_queue_activities_per_second"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double max_task_queue_activities_per_second
     * }
     */
    public static final long max_task_queue_activities_per_second$offset() {
        return max_task_queue_activities_per_second$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double max_task_queue_activities_per_second
     * }
     */
    public static double max_task_queue_activities_per_second(MemorySegment struct) {
        return struct.get(max_task_queue_activities_per_second$LAYOUT, max_task_queue_activities_per_second$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double max_task_queue_activities_per_second
     * }
     */
    public static void max_task_queue_activities_per_second(MemorySegment struct, double fieldValue) {
        struct.set(max_task_queue_activities_per_second$LAYOUT, max_task_queue_activities_per_second$OFFSET, fieldValue);
    }

    private static final OfLong graceful_shutdown_period_millis$LAYOUT = (OfLong)$LAYOUT.select(groupElement("graceful_shutdown_period_millis"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint64_t graceful_shutdown_period_millis
     * }
     */
    public static final OfLong graceful_shutdown_period_millis$layout() {
        return graceful_shutdown_period_millis$LAYOUT;
    }

    private static final long graceful_shutdown_period_millis$OFFSET = $LAYOUT.byteOffset(groupElement("graceful_shutdown_period_millis"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint64_t graceful_shutdown_period_millis
     * }
     */
    public static final long graceful_shutdown_period_millis$offset() {
        return graceful_shutdown_period_millis$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint64_t graceful_shutdown_period_millis
     * }
     */
    public static long graceful_shutdown_period_millis(MemorySegment struct) {
        return struct.get(graceful_shutdown_period_millis$LAYOUT, graceful_shutdown_period_millis$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint64_t graceful_shutdown_period_millis
     * }
     */
    public static void graceful_shutdown_period_millis(MemorySegment struct, long fieldValue) {
        struct.set(graceful_shutdown_period_millis$LAYOUT, graceful_shutdown_period_millis$OFFSET, fieldValue);
    }

    private static final GroupLayout workflow_task_poller_behavior$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("workflow_task_poller_behavior"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior workflow_task_poller_behavior
     * }
     */
    public static final GroupLayout workflow_task_poller_behavior$layout() {
        return workflow_task_poller_behavior$LAYOUT;
    }

    private static final long workflow_task_poller_behavior$OFFSET = $LAYOUT.byteOffset(groupElement("workflow_task_poller_behavior"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior workflow_task_poller_behavior
     * }
     */
    public static final long workflow_task_poller_behavior$offset() {
        return workflow_task_poller_behavior$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior workflow_task_poller_behavior
     * }
     */
    public static MemorySegment workflow_task_poller_behavior(MemorySegment struct) {
        return struct.asSlice(workflow_task_poller_behavior$OFFSET, workflow_task_poller_behavior$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior workflow_task_poller_behavior
     * }
     */
    public static void workflow_task_poller_behavior(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, workflow_task_poller_behavior$OFFSET, workflow_task_poller_behavior$LAYOUT.byteSize());
    }

    private static final OfFloat nonsticky_to_sticky_poll_ratio$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("nonsticky_to_sticky_poll_ratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float nonsticky_to_sticky_poll_ratio
     * }
     */
    public static final OfFloat nonsticky_to_sticky_poll_ratio$layout() {
        return nonsticky_to_sticky_poll_ratio$LAYOUT;
    }

    private static final long nonsticky_to_sticky_poll_ratio$OFFSET = $LAYOUT.byteOffset(groupElement("nonsticky_to_sticky_poll_ratio"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float nonsticky_to_sticky_poll_ratio
     * }
     */
    public static final long nonsticky_to_sticky_poll_ratio$offset() {
        return nonsticky_to_sticky_poll_ratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float nonsticky_to_sticky_poll_ratio
     * }
     */
    public static float nonsticky_to_sticky_poll_ratio(MemorySegment struct) {
        return struct.get(nonsticky_to_sticky_poll_ratio$LAYOUT, nonsticky_to_sticky_poll_ratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float nonsticky_to_sticky_poll_ratio
     * }
     */
    public static void nonsticky_to_sticky_poll_ratio(MemorySegment struct, float fieldValue) {
        struct.set(nonsticky_to_sticky_poll_ratio$LAYOUT, nonsticky_to_sticky_poll_ratio$OFFSET, fieldValue);
    }

    private static final GroupLayout activity_task_poller_behavior$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("activity_task_poller_behavior"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior activity_task_poller_behavior
     * }
     */
    public static final GroupLayout activity_task_poller_behavior$layout() {
        return activity_task_poller_behavior$LAYOUT;
    }

    private static final long activity_task_poller_behavior$OFFSET = $LAYOUT.byteOffset(groupElement("activity_task_poller_behavior"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior activity_task_poller_behavior
     * }
     */
    public static final long activity_task_poller_behavior$offset() {
        return activity_task_poller_behavior$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior activity_task_poller_behavior
     * }
     */
    public static MemorySegment activity_task_poller_behavior(MemorySegment struct) {
        return struct.asSlice(activity_task_poller_behavior$OFFSET, activity_task_poller_behavior$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior activity_task_poller_behavior
     * }
     */
    public static void activity_task_poller_behavior(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, activity_task_poller_behavior$OFFSET, activity_task_poller_behavior$LAYOUT.byteSize());
    }

    private static final GroupLayout nexus_task_poller_behavior$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("nexus_task_poller_behavior"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior nexus_task_poller_behavior
     * }
     */
    public static final GroupLayout nexus_task_poller_behavior$layout() {
        return nexus_task_poller_behavior$LAYOUT;
    }

    private static final long nexus_task_poller_behavior$OFFSET = $LAYOUT.byteOffset(groupElement("nexus_task_poller_behavior"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior nexus_task_poller_behavior
     * }
     */
    public static final long nexus_task_poller_behavior$offset() {
        return nexus_task_poller_behavior$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior nexus_task_poller_behavior
     * }
     */
    public static MemorySegment nexus_task_poller_behavior(MemorySegment struct) {
        return struct.asSlice(nexus_task_poller_behavior$OFFSET, nexus_task_poller_behavior$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCorePollerBehavior nexus_task_poller_behavior
     * }
     */
    public static void nexus_task_poller_behavior(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, nexus_task_poller_behavior$OFFSET, nexus_task_poller_behavior$LAYOUT.byteSize());
    }

    private static final OfBoolean nondeterminism_as_workflow_fail$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("nondeterminism_as_workflow_fail"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool nondeterminism_as_workflow_fail
     * }
     */
    public static final OfBoolean nondeterminism_as_workflow_fail$layout() {
        return nondeterminism_as_workflow_fail$LAYOUT;
    }

    private static final long nondeterminism_as_workflow_fail$OFFSET = $LAYOUT.byteOffset(groupElement("nondeterminism_as_workflow_fail"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool nondeterminism_as_workflow_fail
     * }
     */
    public static final long nondeterminism_as_workflow_fail$offset() {
        return nondeterminism_as_workflow_fail$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool nondeterminism_as_workflow_fail
     * }
     */
    public static boolean nondeterminism_as_workflow_fail(MemorySegment struct) {
        return struct.get(nondeterminism_as_workflow_fail$LAYOUT, nondeterminism_as_workflow_fail$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool nondeterminism_as_workflow_fail
     * }
     */
    public static void nondeterminism_as_workflow_fail(MemorySegment struct, boolean fieldValue) {
        struct.set(nondeterminism_as_workflow_fail$LAYOUT, nondeterminism_as_workflow_fail$OFFSET, fieldValue);
    }

    private static final GroupLayout nondeterminism_as_workflow_fail_for_types$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("nondeterminism_as_workflow_fail_for_types"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray nondeterminism_as_workflow_fail_for_types
     * }
     */
    public static final GroupLayout nondeterminism_as_workflow_fail_for_types$layout() {
        return nondeterminism_as_workflow_fail_for_types$LAYOUT;
    }

    private static final long nondeterminism_as_workflow_fail_for_types$OFFSET = $LAYOUT.byteOffset(groupElement("nondeterminism_as_workflow_fail_for_types"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray nondeterminism_as_workflow_fail_for_types
     * }
     */
    public static final long nondeterminism_as_workflow_fail_for_types$offset() {
        return nondeterminism_as_workflow_fail_for_types$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray nondeterminism_as_workflow_fail_for_types
     * }
     */
    public static MemorySegment nondeterminism_as_workflow_fail_for_types(MemorySegment struct) {
        return struct.asSlice(nondeterminism_as_workflow_fail_for_types$OFFSET, nondeterminism_as_workflow_fail_for_types$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray nondeterminism_as_workflow_fail_for_types
     * }
     */
    public static void nondeterminism_as_workflow_fail_for_types(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, nondeterminism_as_workflow_fail_for_types$OFFSET, nondeterminism_as_workflow_fail_for_types$LAYOUT.byteSize());
    }

    private static final GroupLayout plugins$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("plugins"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray plugins
     * }
     */
    public static final GroupLayout plugins$layout() {
        return plugins$LAYOUT;
    }

    private static final long plugins$OFFSET = $LAYOUT.byteOffset(groupElement("plugins"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray plugins
     * }
     */
    public static final long plugins$offset() {
        return plugins$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray plugins
     * }
     */
    public static MemorySegment plugins(MemorySegment struct) {
        return struct.asSlice(plugins$OFFSET, plugins$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRefArray plugins
     * }
     */
    public static void plugins(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, plugins$OFFSET, plugins$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

