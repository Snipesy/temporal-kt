// Generated by jextract

package io.temporal.sdkbridge;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct TemporalCoreRpcCallOptions {
 *     enum TemporalCoreRpcService service;
 *     struct TemporalCoreByteArrayRef rpc;
 *     struct TemporalCoreByteArrayRef req;
 *     bool retry;
 *     TemporalCoreMetadataRef metadata;
 *     TemporalCoreMetadataRef binary_metadata;
 *     uint32_t timeout_millis;
 *     const struct TemporalCoreCancellationToken *cancellation_token;
 * }
 * }
 */
public class TemporalCoreRpcCallOptions {

    TemporalCoreRpcCallOptions() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        temporal_sdk_core_c_bridge_h.C_INT.withName("service"),
        MemoryLayout.paddingLayout(4),
        TemporalCoreByteArrayRef.layout().withName("rpc"),
        TemporalCoreByteArrayRef.layout().withName("req"),
        temporal_sdk_core_c_bridge_h.C_BOOL.withName("retry"),
        MemoryLayout.paddingLayout(7),
        TemporalCoreByteArrayRefArray.layout().withName("metadata"),
        TemporalCoreByteArrayRefArray.layout().withName("binary_metadata"),
        temporal_sdk_core_c_bridge_h.C_INT.withName("timeout_millis"),
        MemoryLayout.paddingLayout(4),
        temporal_sdk_core_c_bridge_h.C_POINTER.withName("cancellation_token")
    ).withName("TemporalCoreRpcCallOptions");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt service$LAYOUT = (OfInt)$LAYOUT.select(groupElement("service"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum TemporalCoreRpcService service
     * }
     */
    public static final OfInt service$layout() {
        return service$LAYOUT;
    }

    private static final long service$OFFSET = $LAYOUT.byteOffset(groupElement("service"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum TemporalCoreRpcService service
     * }
     */
    public static final long service$offset() {
        return service$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum TemporalCoreRpcService service
     * }
     */
    public static int service(MemorySegment struct) {
        return struct.get(service$LAYOUT, service$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum TemporalCoreRpcService service
     * }
     */
    public static void service(MemorySegment struct, int fieldValue) {
        struct.set(service$LAYOUT, service$OFFSET, fieldValue);
    }

    private static final GroupLayout rpc$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("rpc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef rpc
     * }
     */
    public static final GroupLayout rpc$layout() {
        return rpc$LAYOUT;
    }

    private static final long rpc$OFFSET = $LAYOUT.byteOffset(groupElement("rpc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef rpc
     * }
     */
    public static final long rpc$offset() {
        return rpc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef rpc
     * }
     */
    public static MemorySegment rpc(MemorySegment struct) {
        return struct.asSlice(rpc$OFFSET, rpc$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef rpc
     * }
     */
    public static void rpc(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, rpc$OFFSET, rpc$LAYOUT.byteSize());
    }

    private static final GroupLayout req$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("req"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef req
     * }
     */
    public static final GroupLayout req$layout() {
        return req$LAYOUT;
    }

    private static final long req$OFFSET = $LAYOUT.byteOffset(groupElement("req"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef req
     * }
     */
    public static final long req$offset() {
        return req$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef req
     * }
     */
    public static MemorySegment req(MemorySegment struct) {
        return struct.asSlice(req$OFFSET, req$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporalCoreByteArrayRef req
     * }
     */
    public static void req(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, req$OFFSET, req$LAYOUT.byteSize());
    }

    private static final OfBoolean retry$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("retry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool retry
     * }
     */
    public static final OfBoolean retry$layout() {
        return retry$LAYOUT;
    }

    private static final long retry$OFFSET = $LAYOUT.byteOffset(groupElement("retry"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool retry
     * }
     */
    public static final long retry$offset() {
        return retry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool retry
     * }
     */
    public static boolean retry(MemorySegment struct) {
        return struct.get(retry$LAYOUT, retry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool retry
     * }
     */
    public static void retry(MemorySegment struct, boolean fieldValue) {
        struct.set(retry$LAYOUT, retry$OFFSET, fieldValue);
    }

    private static final GroupLayout metadata$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("metadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef metadata
     * }
     */
    public static final GroupLayout metadata$layout() {
        return metadata$LAYOUT;
    }

    private static final long metadata$OFFSET = $LAYOUT.byteOffset(groupElement("metadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef metadata
     * }
     */
    public static final long metadata$offset() {
        return metadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef metadata
     * }
     */
    public static MemorySegment metadata(MemorySegment struct) {
        return struct.asSlice(metadata$OFFSET, metadata$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef metadata
     * }
     */
    public static void metadata(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, metadata$OFFSET, metadata$LAYOUT.byteSize());
    }

    private static final GroupLayout binary_metadata$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("binary_metadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef binary_metadata
     * }
     */
    public static final GroupLayout binary_metadata$layout() {
        return binary_metadata$LAYOUT;
    }

    private static final long binary_metadata$OFFSET = $LAYOUT.byteOffset(groupElement("binary_metadata"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef binary_metadata
     * }
     */
    public static final long binary_metadata$offset() {
        return binary_metadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef binary_metadata
     * }
     */
    public static MemorySegment binary_metadata(MemorySegment struct) {
        return struct.asSlice(binary_metadata$OFFSET, binary_metadata$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * TemporalCoreMetadataRef binary_metadata
     * }
     */
    public static void binary_metadata(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, binary_metadata$OFFSET, binary_metadata$LAYOUT.byteSize());
    }

    private static final OfInt timeout_millis$LAYOUT = (OfInt)$LAYOUT.select(groupElement("timeout_millis"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t timeout_millis
     * }
     */
    public static final OfInt timeout_millis$layout() {
        return timeout_millis$LAYOUT;
    }

    private static final long timeout_millis$OFFSET = $LAYOUT.byteOffset(groupElement("timeout_millis"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t timeout_millis
     * }
     */
    public static final long timeout_millis$offset() {
        return timeout_millis$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t timeout_millis
     * }
     */
    public static int timeout_millis(MemorySegment struct) {
        return struct.get(timeout_millis$LAYOUT, timeout_millis$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t timeout_millis
     * }
     */
    public static void timeout_millis(MemorySegment struct, int fieldValue) {
        struct.set(timeout_millis$LAYOUT, timeout_millis$OFFSET, fieldValue);
    }

    private static final AddressLayout cancellation_token$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cancellation_token"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct TemporalCoreCancellationToken *cancellation_token
     * }
     */
    public static final AddressLayout cancellation_token$layout() {
        return cancellation_token$LAYOUT;
    }

    private static final long cancellation_token$OFFSET = $LAYOUT.byteOffset(groupElement("cancellation_token"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct TemporalCoreCancellationToken *cancellation_token
     * }
     */
    public static final long cancellation_token$offset() {
        return cancellation_token$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct TemporalCoreCancellationToken *cancellation_token
     * }
     */
    public static MemorySegment cancellation_token(MemorySegment struct) {
        return struct.get(cancellation_token$LAYOUT, cancellation_token$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct TemporalCoreCancellationToken *cancellation_token
     * }
     */
    public static void cancellation_token(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cancellation_token$LAYOUT, cancellation_token$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

